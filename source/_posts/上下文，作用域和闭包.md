title: 执行上下文，作用域和闭包
author: 郭峰
date: 2020-01-07 16:36:48
tags:
---
## 执行上下文（execution context）

* n当代码运行时，会产生一个对应的执行环境，在这个环境中，所有变量会被事先提出来（变量提升），有的直接赋值，有的为默认值 undefined，代码从上往下开始执行，就叫做执行上下文。

 Javascript 中代码的运行环境分为以下三种：

* 全局环境 - 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。

* 函数环境 - 当执行一个函数时，运行函数体中的代码。

* Eval - 在Eval函数内运行的代码。

<!--more-->

### js执行上下文特点

　　1.单线程，在主进程上运行

　　2.同步执行，从上往下按顺序执行

　　3.全局上下文只有一个，浏览器关闭时会被弹出栈

　　4.函数的执行上下文没有数目限制

　　5.函数每被调用一次，都会产生一个新的执行上下文环境
  
### 执行上下文生命周期

　　
　　如图所示，执行上下文共分3个阶段，分别是：

　　　　1.创建阶段

　　　　　　(1).生成变量对象

　　　　　　(2).建立作用域链

　　　　　　(3).确定 this 指向

 

　　　　2.执行阶段

　　　　　　(1).变量赋值

　　　　　　(2).函数引用

　　　　　　(3).执行其他代码

 

　　　　3.销毁阶段

　　　　　　执行完毕出栈，等待回收被销毁
      
    
## 作用域链

* 作用域有上下级的关系，会在当前作用域中寻找变量，如果找不到会沿着创建时作用域链一直往上找，直到找到全局作用域

```
var a=1;
function f1(){
   var b=2;   
   function f2(){ 
     var c=3;
     console.log(a,b,c);
}  
f2();
}
f1();//1 ,2 ,3
```
### 变量声明提升和函数声明提升

* 代码被执行前会有声明提升的过程。只有声明本身会被提升，任何作用域都会进行提升操作。

```
{
    console.log(a);
    var a = 2;  
}
实际上被解析成如下：
{
        var a;
    console.log(a);
    a = 2;  
}

```

## 闭包

* 在一个函数内部定义的另一个函数，当内部函数在包裹他的函数之外被执行时，就会形成闭包。同时内部函数仍然可以访问到包裹函数中的局部变量与函数。

闭包的两个常见用途

* 1. 函数作为返回值

```
封装变量 避免全局中被修改 ，并且记录状态。状态不会销毁丢失
function isFirst() {
    var _list = [];
    return function(id) {
        if(_list.includes(id)) {
            return false
        } 
        _list.push(id)
        return true;
    }
}
var first = isFirst()
first(10) // true
first(10) // false
first(20) // true
```

2. 函数作为参数

```
function wait(message) {
    setTimeout(function timer() {
        console.log(message);
    }, 1000) 
}
wait('hello');

```
* timer 函数传递给setTimeout(),timer就具有了涵盖wait()作用域的闭包，因此保有对变量message的引用，等到1000回调执行后，wait的内部作用域不会消失
> 在定时器、事件监听器、Ajax请求、跨窗口通信、webworker、或者其他的异步或者同步的任务中，只要使用了回调函数，实际上就在使用闭包